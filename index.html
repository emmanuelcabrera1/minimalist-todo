<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Today - Focus</title>

    <!-- Inter Font -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&display=swap" rel="stylesheet">

    <!-- Favicon (SVG Inline) -->
    <link rel="icon"
        href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><circle cx='50' cy='50' r='40' fill='%2334C759'/></svg>">

    <link rel="stylesheet" href="style.css">
</head>

<body>
    <div class="app-container">
        <!-- Layer 1: Today (Focus View) -->
        <div id="view-layer-1" class="view-layer view-active">
            <div class="glass-card">
                <h1 class="header">Today</h1>
                <div class="task-list" id="today-list">
                    <!-- Tasks injected by React -->
                </div>
            </div>
        </div>

        <!-- Layer 2: Lists (Groups View) -->
        <div id="view-layer-2" class="view-layer view-hidden">
            <div class="glass-card">
                <div class="nav-header">
                    <button class="back-btn" onclick="switchLayer(1)">
                        <svg width="20" height="20" viewBox="0 0 20 20" fill="none">
                            <path d="M12 16L6 10L12 4" stroke="currentColor" stroke-width="2" stroke-linecap="round" />
                        </svg>
                    </button>
                    <h1 class="header">My Lists</h1>
                </div>
                <div class="list-groups" id="groups-list">
                    <!-- Groups injected by React -->
                </div>
            </div>
        </div>

        <!-- Layer 3: Group Detail (Tasks in a Group) -->
        <div id="view-layer-3" class="view-layer view-hidden">
            <div class="glass-card">
                <div class="nav-header">
                    <button class="back-btn" onclick="switchLayer(2)">
                        <svg width="20" height="20" viewBox="0 0 20 20" fill="none">
                            <path d="M12 16L6 10L12 4" stroke="currentColor" stroke-width="2" stroke-linecap="round" />
                        </svg>
                    </button>
                    <h1 class="header" id="group-detail-title">Group Tasks</h1>
                </div>
                <div class="task-list" id="group-tasks-list">
                    <!-- Tasks injected by React -->
                </div>
            </div>
        </div>

        <!-- Bottom Menu Trigger -->
        <div class="bottom-menu-trigger" onclick="toggleMenu()"></div>

        <!-- Bottom Menu Sheet -->
        <div class="bottom-menu-sheet" id="bottom-menu">
            <div class="menu-handle"></div>
            <div class="menu-content">
                <button class="menu-item" onclick="switchLayer(1); toggleMenu();">
                    <span class="menu-icon">üìÖ</span>
                    <span class="menu-label">Today</span>
                </button>
                <button class="menu-item" onclick="switchLayer(2); toggleMenu();">
                    <span class="menu-icon">üìã</span>
                    <span class="menu-label">My Lists</span>
                </button>
                <button class="menu-item" onclick="refreshApp(); toggleMenu();">
                    <span class="menu-icon">üîÑ</span>
                    <span class="menu-label">Refresh</span>
                </button>
                <button class="menu-item" onclick="resetData();">
                    <span class="menu-icon">üîÅ</span>
                    <span class="menu-label">Reset Data</span>
                </button>
            </div>
        </div>
    </div>

    <!-- React & Babel - Scripts load synchronously in order -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <!-- Vanilla JS Functions (no JSX) -->
    <script>
        console.log('[App Init] Scripts loaded, waiting for React initialization...');

        // ========== VANILLA JS LAYER CONTROL ==========
        let currentLayer = 1;
        let isMenuOpen = false;
        let currentGroupId = null; // Track which group is being viewed
        let navigationStack = []; // Track navigation breadcrumbs for infinite nesting

        // Storage keys (shared between vanilla JS and React)
        const STORAGE_KEYS = {
            TASKS: 'minimalist-todo-tasks',
            GROUPS: 'minimalist-todo-groups'
        };

        function switchLayer(layerId, groupId = null) {
            currentLayer = layerId;

            if (groupId !== null) {
                currentGroupId = groupId;
            }

            const layer1 = document.getElementById('view-layer-1');
            const layer2 = document.getElementById('view-layer-2');
            const layer3 = document.getElementById('view-layer-3');

            // Hide all layers
            [layer1, layer2, layer3].forEach(layer => {
                layer.classList.add('view-hidden');
                layer.classList.remove('view-active');
            });

            // Show selected layer
            if (layerId === 1) {
                layer1.classList.add('view-active');
                layer1.classList.remove('view-hidden');
            } else if (layerId === 2) {
                layer2.classList.add('view-active');
                layer2.classList.remove('view-hidden');
            } else if (layerId === 3) {
                layer3.classList.add('view-active');
                layer3.classList.remove('view-hidden');
            }

            // AUTO-REFRESH: Trigger refresh when switching layers
            console.log('[Auto-Refresh] Layer switched to:', layerId);
            window.dispatchEvent(new CustomEvent('storage-updated', {
                detail: { key: STORAGE_KEYS.TASKS }
            }));
            window.dispatchEvent(new CustomEvent('storage-updated', {
                detail: { key: STORAGE_KEYS.GROUPS }
            }));
        }

        function toggleMenu() {
            isMenuOpen = !isMenuOpen;
            const menu = document.getElementById('bottom-menu');

            if (isMenuOpen) {
                menu.classList.add('open');
            } else {
                menu.classList.remove('open');
            }
        }

        function refreshApp() {
            console.log('[App] Manual refresh triggered - reloading page...');
            window.location.reload();
        }

        function resetData() {
            console.log('[App] Resetting data to initial state...');
            // Clear all localStorage
            localStorage.removeItem(STORAGE_KEYS.TASKS);
            localStorage.removeItem(STORAGE_KEYS.GROUPS);
            // Reload to initialize with INITIAL_TASKS and INITIAL_GROUPS
            window.location.reload();
        }

        // AUTO-REFRESH: Refresh when user returns to the tab/app
        document.addEventListener('visibilitychange', () => {
            if (!document.hidden) {
                console.log('[Auto-Refresh] User returned to tab - refreshing data');
                window.dispatchEvent(new CustomEvent('storage-updated', {
                    detail: { key: STORAGE_KEYS.TASKS }
                }));
                window.dispatchEvent(new CustomEvent('storage-updated', {
                    detail: { key: STORAGE_KEYS.GROUPS }
                }));
            }
        });
    </script>

    <!-- App Logic with JSX (INLINED for Safari/iOS compatibility) -->
    <script type="text/babel">
        // ==========================================
        // MINIMALIST TODO APP - REACT LOGIC
        // ==========================================

        const { useState, useEffect } = React;

        // ========== STORAGE HELPERS ==========
        // Note: STORAGE_KEYS is defined in vanilla JS section above

        // Generate unique ID to prevent collisions (timestamp + random) - Safari compatible
        const generateUniqueId = () => {
            return Date.now() + '-' + Math.random().toString(36).substring(2, 11);
        };

        /**
         * Detects if a task is part of a circular parent-child reference.
         * Traverses up the parentId chain and checks for revisited nodes.
         * @param {string|number} taskId - The ID of the task to check.
         * @param {Array} allTasks - The full array of tasks.
         * @returns {boolean} - True if a cycle is detected, false otherwise.
         */
        const detectCycle = (taskId, allTasks) => {
            const visited = new Set();
            let currentId = taskId;

            while (currentId !== null) {
                if (visited.has(currentId)) {
                    return true; // Cycle detected
                }
                visited.add(currentId);

                const currentTask = allTasks.find(t => t.id === currentId);
                if (!currentTask) break; // Task not found, no cycle from here

                currentId = currentTask.parentId;
            }
            return false;
        };

        /**
         * Sanitizes the task array by breaking any circular references.
         * Tasks involved in a cycle have their parentId set to null.
         * @param {Array} tasks - The array of tasks to sanitize.
         * @returns {Array} - The sanitized array of tasks.
         */
        const sanitizeTasks = (tasks) => {
            return tasks.map(task => {
                if (task.parentId !== null && detectCycle(task.id, tasks)) {
                    console.warn(`[Cycle Detection] Breaking cycle for task: ${task.id} ("${task.text}")`);
                    return { ...task, parentId: null };
                }
                return task;
            });
        };

        const loadFromStorage = (key, fallback) => {
            try {
                const stored = localStorage.getItem(key);
                if (!stored) return fallback;

                let data = JSON.parse(stored);

                // DATA MIGRATION: Add parentId field to old tasks that don't have it
                if (key === STORAGE_KEYS.TASKS && Array.isArray(data)) {
                    data = data.map(task => ({
                        ...task,
                        parentId: task.parentId !== undefined ? task.parentId : null
                    }));

                    // CYCLE DETECTION: Sanitize tasks to break any circular references
                    data = sanitizeTasks(data);
                }

                return data;
            } catch (error) {
                console.error('Error loading from storage:', error);
                return fallback;
            }
        };

        const saveToStorage = (key, data) => {
            try {
                localStorage.setItem(key, JSON.stringify(data));
                // Notify all components that data has changed
                window.dispatchEvent(new CustomEvent('storage-updated', { detail: { key } }));
            } catch (error) {
                console.error('Error saving to storage:', error);
            }
        };

        // ========== DATA ==========
        const INITIAL_TASKS = [
            // Top-level tasks in Work group
            { id: 1, text: 'Q1 Planning', completed: false, groupId: 1, parentId: null, showInToday: true },
            { id: 2, text: 'Weekly Standup', completed: false, groupId: 1, parentId: null, showInToday: false },

            // Children of "Q1 Planning" (task 1)
            { id: 9, text: 'Budget Review', completed: false, groupId: 1, parentId: 1, showInToday: false },
            { id: 10, text: 'Team Goals', completed: false, groupId: 1, parentId: 1, showInToday: false },

            // Children of "Budget Review" (task 9) - demonstrating deeper nesting
            { id: 11, text: 'Analyze Q4 expenses', completed: false, groupId: 1, parentId: 9, showInToday: false },
            { id: 12, text: 'Forecast Q2', completed: false, groupId: 1, parentId: 9, showInToday: false },

            // Top-level tasks in Personal group
            { id: 3, text: 'Home Renovation', completed: false, groupId: 2, parentId: null, showInToday: false },
            { id: 5, text: 'Meditate for 15 mins', completed: false, groupId: 2, parentId: null, showInToday: true },

            // Children of "Home Renovation" (task 3)
            { id: 13, text: 'Kitchen remodel', completed: false, groupId: 2, parentId: 3, showInToday: false },
            { id: 14, text: 'Bathroom update', completed: false, groupId: 2, parentId: 3, showInToday: false },

            // Top-level tasks in Groceries group
            { id: 4, text: 'Buy groceries', completed: false, groupId: 3, parentId: null, showInToday: false },
            { id: 8, text: 'Buy milk', completed: false, groupId: 3, parentId: null, showInToday: false }
        ];

        const INITIAL_GROUPS = [
            { id: 1, name: 'Work', count: 2, color: '#34C759' },
            { id: 2, name: 'Personal', count: 2, color: '#007AFF' },
            { id: 3, name: 'Groceries', count: 2, color: '#FF9500' }
        ];

        // ========== COMPONENTS ==========

        // Task Item Component (for Today view - navigates to group)
        function TaskItem({ task, onToggle, onDelete, onNavigateToGroup, groups }) {
            // Find the group name for this task
            const group = groups.find(g => g.id === task.groupId);
            const groupName = group ? group.name : 'Unknown';

            return (
                <div className={`task-item ${task.completed ? 'completed' : ''}`}>
                    <div
                        className={`checkbox ${task.completed ? 'checked' : ''}`}
                        onClick={() => onToggle(task.id)}
                        role="checkbox"
                        aria-checked={task.completed}
                        tabIndex={0}
                        onKeyPress={(e) => e.key === 'Enter' && onToggle(task.id)}
                    />
                    <div
                        className="task-text task-navigable"
                        onClick={() => onNavigateToGroup(task)}
                        style={{ cursor: 'pointer' }}
                    >
                        <div>{task.text}</div>
                        <span className="task-group-label">{groupName}</span>
                    </div>
                    <button
                        className="delete-btn"
                        onClick={() => onDelete(task.id)}
                        aria-label={`Delete task: ${task.text}`}
                    >
                        √ó
                    </button>
                </div>
            );
        }

        // Group Item Component
        function GroupItem({ group, onDelete, onClick }) {
            return (
                <div className="group-item">
                    <div
                        className="group-content"
                        onClick={() => onClick(group.id, group.name)}
                        style={{ cursor: 'pointer', flex: 1 }}
                    >
                        <div className="group-name">{group.name}</div>
                        <div className="group-count">{group.count} {group.count === 1 ? 'task' : 'tasks'}</div>
                    </div>
                    <button
                        className="delete-btn"
                        onClick={(e) => {
                            e.stopPropagation();
                            onDelete(group.id);
                        }}
                        aria-label={`Delete group: ${group.name}`}
                    >
                        √ó
                    </button>
                </div>
            );
        }

        // Add Task Form
        function AddTaskForm({ onAdd }) {
            const [text, setText] = useState('');
            const MAX_LENGTH = 500;

            const handleSubmit = (e) => {
                e.preventDefault();
                const trimmed = text.trim();
                if (trimmed && trimmed.length <= MAX_LENGTH) {
                    onAdd(trimmed);
                    setText('');
                }
            };

            return (
                <form className="add-form" onSubmit={handleSubmit}>
                    <label htmlFor="task-input" className="visually-hidden">Add new task</label>
                    <input
                        id="task-input"
                        type="text"
                        className="add-input"
                        placeholder="Add a new task..."
                        value={text}
                        onChange={(e) => setText(e.target.value)}
                        maxLength={MAX_LENGTH}
                    />
                    <button type="submit" className="add-btn" aria-label="Add task">+</button>
                </form>
            );
        }

        // Add Group Form
        function AddGroupForm({ onAdd }) {
            const [name, setName] = useState('');
            const MAX_LENGTH = 100;

            const handleSubmit = (e) => {
                e.preventDefault();
                const trimmed = name.trim();
                if (trimmed && trimmed.length <= MAX_LENGTH) {
                    onAdd(trimmed);
                    setName('');
                }
            };

            return (
                <form className="add-form" onSubmit={handleSubmit}>
                    <label htmlFor="group-input" className="visually-hidden">Add new list</label>
                    <input
                        id="group-input"
                        type="text"
                        className="add-input"
                        placeholder="Add a new list..."
                        value={name}
                        onChange={(e) => setName(e.target.value)}
                        maxLength={MAX_LENGTH}
                    />
                    <button type="submit" className="add-btn" aria-label="Add list">+</button>
                </form>
            );
        }

        // Group Task Item Component (with star toggle for showInToday, infinite nesting, and move arrows)
        function GroupTaskItem({ task, onToggle, onDelete, onToggleToday, onEdit, onNavigate, onMoveTask, hasChildren, isSelected, onSelect }) {
            const [isEditing, setIsEditing] = useState(false);
            const [editText, setEditText] = useState(task.text);

            const handleSave = () => {
                const trimmed = editText.trim();
                if (trimmed && trimmed !== task.text) {
                    onEdit(task.id, trimmed);
                }
                setIsEditing(false);
            };

            const handleCancel = () => {
                setEditText(task.text);
                setIsEditing(false);
            };

            const handleKeyDown = (e) => {
                if (e.key === 'Enter') {
                    e.preventDefault();
                    handleSave();
                } else if (e.key === 'Escape') {
                    handleCancel();
                }
            };

            // Click on task text toggles arrow buttons (only for this task)
            const handleTextClick = () => {
                onSelect(isSelected ? null : task.id);
            };

            const handleMoveUp = (e) => {
                e.stopPropagation();
                onMoveTask(task.id, 'up');
            };

            const handleMoveDown = (e) => {
                e.stopPropagation();
                onMoveTask(task.id, 'down');
            };

            const handleEditClick = (e) => {
                e.stopPropagation();
                onSelect(null);
                setIsEditing(true);
            };

            return (
                <div className={`task-item ${task.completed ? 'completed' : ''} ${isSelected ? 'show-arrows' : ''}`}>
                    <div
                        className={`checkbox ${task.completed ? 'checked' : ''}`}
                        onClick={() => onToggle(task.id)}
                        role="checkbox"
                        aria-checked={task.completed}
                        tabIndex={0}
                        onKeyPress={(e) => e.key === 'Enter' && onToggle(task.id)}
                    />
                    {isEditing ? (
                        <input
                            type="text"
                            className="task-edit-input"
                            value={editText}
                            onChange={(e) => setEditText(e.target.value)}
                            onBlur={handleSave}
                            onKeyDown={handleKeyDown}
                            autoFocus
                            maxLength={500}
                        />
                    ) : (
                        <div
                            className="task-text task-editable"
                            onClick={handleTextClick}
                        >
                            {task.text}
                        </div>
                    )}
                    {isSelected && (
                        <>
                            <button
                                className="move-btn move-up"
                                onClick={handleMoveUp}
                                aria-label="Move up"
                            >
                                ‚Üë
                            </button>
                            <button
                                className="move-btn move-down"
                                onClick={handleMoveDown}
                                aria-label="Move down"
                            >
                                ‚Üì
                            </button>
                            <button
                                className="edit-btn"
                                onClick={handleEditClick}
                                aria-label="Edit task"
                            >
                                ‚úèÔ∏è
                            </button>
                        </>
                    )}
                    <button
                        className="nav-btn"
                        onClick={() => onNavigate(task.id, task.text)}
                        aria-label={`Add subtasks to: ${task.text}`}
                    >
                        ‚Ä∫
                    </button>
                    <button
                        className="star-btn"
                        onClick={() => onToggleToday(task.id)}
                        aria-label={task.showInToday ? "Remove from Today" : "Add to Today"}
                        style={{
                            background: 'none',
                            border: 'none',
                            fontSize: '20px',
                            cursor: 'pointer',
                            padding: '5px',
                            marginRight: '5px'
                        }}
                    >
                        {task.showInToday ? '‚≠ê' : '‚òÜ'}
                    </button>
                    <button
                        className="delete-btn"
                        onClick={() => onDelete(task.id)}
                        aria-label={`Delete task: ${task.text}`}
                    >
                        √ó
                    </button>
                </div>
            );
        }

        // Group Detail View Component (supports infinite nesting)
        function GroupDetailView({ tasks, groupId, parentTaskId, onToggle, onDelete, onAdd, onToggleToday, onEdit, onNavigate, onMoveTask }) {
            const [selectedTaskId, setSelectedTaskId] = useState(null);

            // Filter tasks based on context
            const currentTasks = tasks.filter(task => {
                if (parentTaskId === null) {
                    // Show top-level tasks in the group
                    return task.groupId === groupId && task.parentId === null;
                } else {
                    // Show children of the current parent task
                    return task.parentId === parentTaskId;
                }
            });

            // Helper to check if a task has children
            const hasChildren = (taskId) => {
                return tasks.some(t => t.parentId === taskId);
            };

            return (
                <>
                    {currentTasks.map(task => (
                        <GroupTaskItem
                            key={task.id}
                            task={task}
                            onToggle={onToggle}
                            onDelete={onDelete}
                            onToggleToday={onToggleToday}
                            onEdit={onEdit}
                            onNavigate={onNavigate}
                            onMoveTask={onMoveTask}
                            hasChildren={hasChildren(task.id)}
                            isSelected={selectedTaskId === task.id}
                            onSelect={setSelectedTaskId}
                        />
                    ))}
                    <AddTaskForm onAdd={onAdd} />
                </>
            );
        }

        // Today View Component
        function TodayView({ tasks, groups, onToggle, onDelete, onNavigateToGroup }) {
            // Only show tasks marked for today
            const todayTasks = tasks.filter(task => task.showInToday);

            if (todayTasks.length === 0) {
                return (
                    <div style={{ textAlign: 'center', padding: '40px 20px', color: '#8E8E93' }}>
                        <p>No tasks for today</p>
                        <p style={{ fontSize: '14px', marginTop: '10px' }}>
                            Go to My Lists and select tasks to add them here
                        </p>
                    </div>
                );
            }

            return (
                <>
                    {todayTasks.map(task => (
                        <TaskItem
                            key={task.id}
                            task={task}
                            groups={groups}
                            onToggle={onToggle}
                            onDelete={onDelete}
                            onNavigateToGroup={onNavigateToGroup}
                        />
                    ))}
                </>
            );
        }

        // Lists View Component
        function ListsView({ groups, onDelete, onAdd, onGroupClick }) {
            return (
                <>
                    {groups.map(group => (
                        <GroupItem
                            key={group.id}
                            group={group}
                            onDelete={onDelete}
                            onClick={onGroupClick}
                        />
                    ))}
                    <AddGroupForm onAdd={onAdd} />
                </>
            );
        }

        // Today Container Component
        function TodayContainer() {
            const [tasks, setTasks] = useState(() =>
                loadFromStorage(STORAGE_KEYS.TASKS, INITIAL_TASKS)
            );
            const [groups, setGroups] = useState(() =>
                loadFromStorage(STORAGE_KEYS.GROUPS, INITIAL_GROUPS)
            );

            // Listen for storage updates from other components
            useEffect(() => {
                const handleStorageUpdate = (event) => {
                    if (event.detail.key === STORAGE_KEYS.TASKS) {
                        setTasks(loadFromStorage(STORAGE_KEYS.TASKS, INITIAL_TASKS));
                    } else if (event.detail.key === STORAGE_KEYS.GROUPS) {
                        setGroups(loadFromStorage(STORAGE_KEYS.GROUPS, INITIAL_GROUPS));
                    }
                };
                window.addEventListener('storage-updated', handleStorageUpdate);
                return () => window.removeEventListener('storage-updated', handleStorageUpdate);
            }, []);

            useEffect(() => {
                saveToStorage(STORAGE_KEYS.TASKS, tasks);
            }, [tasks]);

            const toggleTask = (id) => {
                setTasks(tasks.map(task =>
                    task.id === id ? { ...task, completed: !task.completed } : task
                ));
                console.log('[Task] Toggled task:', id);
            };

            const deleteTask = (id) => {
                setTasks(tasks.filter(task => task.id !== id));
                console.log('[Task] Deleted task:', id);
            };

            const navigateToGroup = (task) => {
                console.log('[Navigation] Jumping to group for task:', task.id, task.text);
                // Find the group
                const group = groups.find(g => g.id === task.groupId);
                if (group) {
                    // Dispatch group selection event (same as clicking a group)
                    window.dispatchEvent(new CustomEvent('group-selected', {
                        detail: { groupId: group.id, groupName: group.name }
                    }));
                    // Switch to layer 3 (group detail view)
                    switchLayer(3, group.id);
                }
            };

            return (
                <TodayView
                    tasks={tasks}
                    groups={groups}
                    onToggle={toggleTask}
                    onDelete={deleteTask}
                    onNavigateToGroup={navigateToGroup}
                />
            );
        }

        // Groups Container Component
        function GroupsContainer() {
            const [groups, setGroups] = useState(() =>
                loadFromStorage(STORAGE_KEYS.GROUPS, INITIAL_GROUPS)
            );
            const [tasks, setTasks] = useState(() =>
                loadFromStorage(STORAGE_KEYS.TASKS, INITIAL_TASKS)
            );

            // Listen for storage updates
            useEffect(() => {
                const handleStorageUpdate = (event) => {
                    if (event.detail.key === STORAGE_KEYS.TASKS) {
                        setTasks(loadFromStorage(STORAGE_KEYS.TASKS, INITIAL_TASKS));
                    } else if (event.detail.key === STORAGE_KEYS.GROUPS) {
                        setGroups(loadFromStorage(STORAGE_KEYS.GROUPS, INITIAL_GROUPS));
                    }
                };
                window.addEventListener('storage-updated', handleStorageUpdate);
                return () => window.removeEventListener('storage-updated', handleStorageUpdate);
            }, []);

            // Update group counts based on TOP-LEVEL tasks only (parentId === null)
            const groupsWithCounts = groups.map(group => ({
                ...group,
                count: tasks.filter(task => task.groupId === group.id && task.parentId === null).length
            }));

            useEffect(() => {
                saveToStorage(STORAGE_KEYS.GROUPS, groups);
            }, [groups]);

            const addGroup = (name) => {
                const newGroup = {
                    id: generateUniqueId(),
                    name: name,
                    count: 0,
                    color: '#34C759'
                };
                setGroups([...groups, newGroup]);
                console.log('[Group] Added new group:', newGroup);
            };

            const deleteGroup = (id) => {
                setGroups(groups.filter(group => group.id !== id));
                console.log('[Group] Deleted group:', id);
            };

            const handleGroupClick = (groupId, groupName) => {
                console.log('[Group] Clicked group:', groupId, groupName);
                // Update the group detail title
                const titleElement = document.getElementById('group-detail-title');
                if (titleElement) {
                    titleElement.textContent = groupName;
                }
                // Switch to layer 3 and set current group
                switchLayer(3, groupId);
                // Trigger React re-render of group detail view
                window.dispatchEvent(new CustomEvent('group-selected', { detail: { groupId, groupName } }));
            };

            return (
                <ListsView
                    groups={groupsWithCounts}
                    onDelete={deleteGroup}
                    onAdd={addGroup}
                    onGroupClick={handleGroupClick}
                />
            );
        }

        // Group Detail Container Component (with infinite nesting support)
        function GroupDetailContainer() {
            const [tasks, setTasks] = useState(() =>
                loadFromStorage(STORAGE_KEYS.TASKS, INITIAL_TASKS)
            );
            const [currentGroup, setCurrentGroup] = useState(null);
            const [navStack, setNavStack] = useState([]); // Navigation breadcrumb stack

            // Listen for storage updates from other components
            useEffect(() => {
                const handleStorageUpdate = (event) => {
                    if (event.detail.key === STORAGE_KEYS.TASKS) {
                        setTasks(loadFromStorage(STORAGE_KEYS.TASKS, INITIAL_TASKS));
                    }
                };
                window.addEventListener('storage-updated', handleStorageUpdate);
                return () => window.removeEventListener('storage-updated', handleStorageUpdate);
            }, []);

            useEffect(() => {
                saveToStorage(STORAGE_KEYS.TASKS, tasks);
            }, [tasks]);

            // Listen for group selection event
            useEffect(() => {
                const handleGroupSelected = (event) => {
                    setCurrentGroup(event.detail.groupId);
                    setNavStack([]); // Reset navigation stack when entering a group
                    // Update header
                    const titleElement = document.getElementById('group-detail-title');
                    if (titleElement) {
                        titleElement.textContent = event.detail.groupName;
                    }
                };
                window.addEventListener('group-selected', handleGroupSelected);
                return () => window.removeEventListener('group-selected', handleGroupSelected);
            }, []);

            const toggleTask = (id) => {
                setTasks(tasks.map(task =>
                    task.id === id ? { ...task, completed: !task.completed } : task
                ));
                console.log('[Task] Toggled task:', id);
            };

            const toggleTodayStatus = (id) => {
                setTasks(tasks.map(task =>
                    task.id === id ? { ...task, showInToday: !task.showInToday } : task
                ));
                console.log('[Task] Toggled showInToday for task:', id);
            };

            const editTask = (id, newText) => {
                setTasks(tasks.map(task =>
                    task.id === id ? { ...task, text: newText } : task
                ));
                console.log('[Task] Edited task:', id, 'New text:', newText);
            };

            const navigateIntoTask = (taskId, taskName) => {
                console.log('[Navigation] Entering task:', taskId, taskName);
                // Add current context to navigation stack
                setNavStack([...navStack, { id: taskId, name: taskName }]);
                // Update header to show current task name
                const titleElement = document.getElementById('group-detail-title');
                if (titleElement) {
                    titleElement.textContent = taskName;
                }
            };

            const navigateBack = () => {
                if (navStack.length === 0) {
                    // At top level of group, go back to groups list
                    switchLayer(2);
                } else {
                    // Go up one level in the task hierarchy
                    const newStack = [...navStack];
                    newStack.pop();
                    setNavStack(newStack);
                    // Update header
                    const titleElement = document.getElementById('group-detail-title');
                    if (titleElement) {
                        if (newStack.length === 0) {
                            // Back to group level - need to get group name
                            const groups = loadFromStorage(STORAGE_KEYS.GROUPS, []);
                            const group = groups.find(g => g.id === currentGroup);
                            titleElement.textContent = group ? group.name : 'Group Tasks';
                        } else {
                            // Back to parent task
                            titleElement.textContent = newStack[newStack.length - 1].name;
                        }
                    }
                    console.log('[Navigation] Back to level:', newStack.length);
                }
            };

            // Update back button behavior
            useEffect(() => {
                const backBtn = document.querySelector('#view-layer-3 .back-btn');
                if (backBtn) {
                    backBtn.onclick = navigateBack;
                }
            }, [navStack, currentGroup]);

            const addTask = (text) => {
                if (!currentGroup) return;
                const currentParentId = navStack.length > 0 ? navStack[navStack.length - 1].id : null;
                const newTask = {
                    id: generateUniqueId(),
                    text: text,
                    completed: false,
                    groupId: currentGroup,
                    parentId: currentParentId,
                    showInToday: false
                };
                setTasks([...tasks, newTask]);
                console.log('[Task] Added new task:', newTask);
            };

            const deleteTask = (id) => {
                // Delete task and all its descendants
                const deleteRecursive = (taskId) => {
                    const childIds = tasks.filter(t => t.parentId === taskId).map(t => t.id);
                    childIds.forEach(childId => deleteRecursive(childId));
                    return [taskId, ...childIds.flatMap(deleteRecursive)];
                };

                const idsToDelete = [id, ...tasks.filter(t => t.parentId === id).map(t => t.id)];
                setTasks(tasks.filter(task => !idsToDelete.includes(task.id)));
                console.log('[Task] Deleted task and children:', id);
            };

            // Move task up or down by ONE position within its sibling group
            const moveTask = (taskId, direction) => {
                const taskToMove = tasks.find(t => t.id === taskId);
                if (!taskToMove) return;

                // Get sibling IDs in their current order within the tasks array
                const siblingIds = tasks
                    .filter(t => t.parentId === taskToMove.parentId && t.groupId === taskToMove.groupId)
                    .map(t => t.id);

                const currentPosInSiblings = siblingIds.indexOf(taskId);

                // Calculate new position
                let newPosInSiblings;
                if (direction === 'up' && currentPosInSiblings > 0) {
                    newPosInSiblings = currentPosInSiblings - 1;
                } else if (direction === 'down' && currentPosInSiblings < siblingIds.length - 1) {
                    newPosInSiblings = currentPosInSiblings + 1;
                } else {
                    return; // Can't move further
                }

                // Get the task we're swapping with
                const swapWithId = siblingIds[newPosInSiblings];

                // Find their positions in the full tasks array
                const taskIndex = tasks.findIndex(t => t.id === taskId);
                const swapIndex = tasks.findIndex(t => t.id === swapWithId);

                // Swap the two tasks
                const newTasks = [...tasks];
                [newTasks[taskIndex], newTasks[swapIndex]] = [newTasks[swapIndex], newTasks[taskIndex]];

                setTasks(newTasks);
                console.log(`[Task] Moved ${direction}:`, taskId);
            };

            if (!currentGroup) {
                return <div style={{ textAlign: 'center', padding: '40px 20px', color: '#8E8E93' }}>
                    Select a group to view tasks
                </div>;
            }

            // Determine current parent context
            const currentParentId = navStack.length > 0 ? navStack[navStack.length - 1].id : null;

            return (
                <GroupDetailView
                    tasks={tasks}
                    groupId={currentGroup}
                    parentTaskId={currentParentId}
                    onToggle={toggleTask}
                    onDelete={deleteTask}
                    onAdd={addTask}
                    onToggleToday={toggleTodayStatus}
                    onEdit={editTask}
                    onNavigate={navigateIntoTask}
                    onMoveTask={moveTask}
                />
            );
        }

        // ========== RENDER ==========
        // ========== RENDER ==========
        const initApp = () => {
            console.log('[App Init] Starting React initialization...');

            try {
                // Verify React is loaded
                if (typeof React === 'undefined') {
                    throw new Error('React library not loaded');
                }
                if (typeof ReactDOM === 'undefined') {
                    throw new Error('ReactDOM library not loaded');
                }
                console.log('[App Init] React libraries verified ‚úì');

                // Render Today view
                const todayContainer = document.getElementById('today-list');
                if (todayContainer) {
                    console.log('[App Init] Rendering TodayContainer...');
                    const todayRoot = ReactDOM.createRoot(todayContainer);
                    todayRoot.render(<TodayContainer />);
                    console.log('[App Init] TodayContainer rendered ‚úì');
                } else {
                    console.error('[App Error] today-list container not found!');
                }

                // Render Groups view
                const groupsContainer = document.getElementById('groups-list');
                if (groupsContainer) {
                    console.log('[App Init] Rendering GroupsContainer...');
                    const groupsRoot = ReactDOM.createRoot(groupsContainer);
                    groupsRoot.render(<GroupsContainer />);
                    console.log('[App Init] GroupsContainer rendered ‚úì');
                } else {
                    console.error('[App Error] groups-list container not found!');
                }

                // Render Group Detail view
                const groupDetailContainer = document.getElementById('group-tasks-list');
                if (groupDetailContainer) {
                    console.log('[App Init] Rendering GroupDetailContainer...');
                    const groupDetailRoot = ReactDOM.createRoot(groupDetailContainer);
                    groupDetailRoot.render(<GroupDetailContainer />);
                    console.log('[App Init] GroupDetailContainer rendered ‚úì');
                } else {
                    console.error('[App Error] group-tasks-list container not found!');
                }

                console.log('[App Init] ‚úÖ Application initialized successfully!');
            } catch (error) {
                console.error('[App Error] ‚ùå Failed to initialize application:', error);
                console.error('[App Error] Stack trace:', error.stack);
                // Display user-friendly error
                const errorMsg = document.createElement('div');
                errorMsg.style.cssText = 'position:fixed;top:50%;left:50%;transform:translate(-50%,-50%);background:rgba(255,59,48,0.9);color:white;padding:20px;border-radius:12px;text-align:center;z-index:9999;';
                errorMsg.innerHTML = `<strong>App Error</strong><br>Failed to load. Check console for details.<br><small>${error.message}</small>`;
                document.body.appendChild(errorMsg);
            }
        };

        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', initApp);
        } else {
            // DOM already ready, run immediately
            initApp();
        }
    </script>
</body>

</html>